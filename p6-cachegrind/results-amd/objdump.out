
./a.out:     file format elf64-x86-64


Disassembly of section .init:

00000000004007b0 <_init>:
  4007b0:	48 83 ec 08          	sub    $0x8,%rsp
  4007b4:	48 8b 05 1d 12 20 00 	mov    0x20121d(%rip),%rax        # 6019d8 <_DYNAMIC+0x200>
  4007bb:	48 85 c0             	test   %rax,%rax
  4007be:	74 05                	je     4007c5 <_init+0x15>
  4007c0:	e8 3b 00 00 00       	callq  400800 <__gmon_start__@plt>
  4007c5:	48 83 c4 08          	add    $0x8,%rsp
  4007c9:	c3                   	retq   

Disassembly of section .plt:

00000000004007d0 <printf@plt-0x10>:
  4007d0:	ff 35 12 12 20 00    	pushq  0x201212(%rip)        # 6019e8 <_GLOBAL_OFFSET_TABLE_+0x8>
  4007d6:	ff 25 14 12 20 00    	jmpq   *0x201214(%rip)        # 6019f0 <_GLOBAL_OFFSET_TABLE_+0x10>
  4007dc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000004007e0 <printf@plt>:
  4007e0:	ff 25 12 12 20 00    	jmpq   *0x201212(%rip)        # 6019f8 <_GLOBAL_OFFSET_TABLE_+0x18>
  4007e6:	68 00 00 00 00       	pushq  $0x0
  4007eb:	e9 e0 ff ff ff       	jmpq   4007d0 <_init+0x20>

00000000004007f0 <memset@plt>:
  4007f0:	ff 25 0a 12 20 00    	jmpq   *0x20120a(%rip)        # 601a00 <_GLOBAL_OFFSET_TABLE_+0x20>
  4007f6:	68 01 00 00 00       	pushq  $0x1
  4007fb:	e9 d0 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400800 <__gmon_start__@plt>:
  400800:	ff 25 02 12 20 00    	jmpq   *0x201202(%rip)        # 601a08 <_GLOBAL_OFFSET_TABLE_+0x28>
  400806:	68 02 00 00 00       	pushq  $0x2
  40080b:	e9 c0 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400810 <puts@plt>:
  400810:	ff 25 fa 11 20 00    	jmpq   *0x2011fa(%rip)        # 601a10 <_GLOBAL_OFFSET_TABLE_+0x30>
  400816:	68 03 00 00 00       	pushq  $0x3
  40081b:	e9 b0 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400820 <putchar@plt>:
  400820:	ff 25 f2 11 20 00    	jmpq   *0x2011f2(%rip)        # 601a18 <_GLOBAL_OFFSET_TABLE_+0x38>
  400826:	68 04 00 00 00       	pushq  $0x4
  40082b:	e9 a0 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400830 <__libc_start_main@plt>:
  400830:	ff 25 ea 11 20 00    	jmpq   *0x2011ea(%rip)        # 601a20 <_GLOBAL_OFFSET_TABLE_+0x40>
  400836:	68 05 00 00 00       	pushq  $0x5
  40083b:	e9 90 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400840 <strtol@plt>:
  400840:	ff 25 e2 11 20 00    	jmpq   *0x2011e2(%rip)        # 601a28 <_GLOBAL_OFFSET_TABLE_+0x48>
  400846:	68 06 00 00 00       	pushq  $0x6
  40084b:	e9 80 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400850 <gsl_matrix_view_array@plt>:
  400850:	ff 25 da 11 20 00    	jmpq   *0x2011da(%rip)        # 601a30 <_GLOBAL_OFFSET_TABLE_+0x50>
  400856:	68 07 00 00 00       	pushq  $0x7
  40085b:	e9 70 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400860 <clock@plt>:
  400860:	ff 25 d2 11 20 00    	jmpq   *0x2011d2(%rip)        # 601a38 <_GLOBAL_OFFSET_TABLE_+0x58>
  400866:	68 08 00 00 00       	pushq  $0x8
  40086b:	e9 60 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400870 <gsl_blas_dgemm@plt>:
  400870:	ff 25 ca 11 20 00    	jmpq   *0x2011ca(%rip)        # 601a40 <_GLOBAL_OFFSET_TABLE_+0x60>
  400876:	68 09 00 00 00       	pushq  $0x9
  40087b:	e9 50 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400880 <fwrite@plt>:
  400880:	ff 25 c2 11 20 00    	jmpq   *0x2011c2(%rip)        # 601a48 <_GLOBAL_OFFSET_TABLE_+0x68>
  400886:	68 0a 00 00 00       	pushq  $0xa
  40088b:	e9 40 ff ff ff       	jmpq   4007d0 <_init+0x20>

0000000000400890 <rand@plt>:
  400890:	ff 25 ba 11 20 00    	jmpq   *0x2011ba(%rip)        # 601a50 <_GLOBAL_OFFSET_TABLE_+0x70>
  400896:	68 0b 00 00 00       	pushq  $0xb
  40089b:	e9 30 ff ff ff       	jmpq   4007d0 <_init+0x20>

00000000004008a0 <fprintf@plt>:
  4008a0:	ff 25 b2 11 20 00    	jmpq   *0x2011b2(%rip)        # 601a58 <_GLOBAL_OFFSET_TABLE_+0x78>
  4008a6:	68 0c 00 00 00       	pushq  $0xc
  4008ab:	e9 20 ff ff ff       	jmpq   4007d0 <_init+0x20>

Disassembly of section .text:

00000000004008b0 <main>:
#endif

mat_t m1, m2, m3;

int main(int argc, char *argv[])
{
  4008b0:	55                   	push   %rbp
  4008b1:	53                   	push   %rbx
  4008b2:	48 89 f5             	mov    %rsi,%rbp
  4008b5:	48 83 ec 08          	sub    $0x8,%rsp
    int alg = 0;
    if (argc == 2)
  4008b9:	83 ff 02             	cmp    $0x2,%edi
  4008bc:	74 23                	je     4008e1 <main+0x31>
        alg = atoi(argv[1]);
    if (alg == 0) {
        fprintf(stderr,
  4008be:	48 8b 55 00          	mov    0x0(%rbp),%rdx
  4008c2:	48 8b 3d b7 11 20 00 	mov    0x2011b7(%rip),%rdi        # 601a80 <stderr@@GLIBC_2.2.5>
  4008c9:	be 18 14 40 00       	mov    $0x401418,%esi
  4008ce:	31 c0                	xor    %eax,%eax
  4008d0:	e8 cb ff ff ff       	callq  4008a0 <fprintf@plt>
                "Usage: %s N\n"
                "       where N is algorithm number\n", argv[0]);
        return 1;
  4008d5:	b8 01 00 00 00       	mov    $0x1,%eax
    };
    clock_t end = clock();
    print(m3);
    printf("%.2f seconds\n", (double) (end - start) / CLOCKS_PER_SEC);
    return 0;
}
  4008da:	48 83 c4 08          	add    $0x8,%rsp
  4008de:	5b                   	pop    %rbx
  4008df:	5d                   	pop    %rbp
  4008e0:	c3                   	retq   
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline int
__NTH (atoi (const char *__nptr))
{
  return (int) strtol (__nptr, (char **) NULL, 10);
  4008e1:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
  4008e5:	ba 0a 00 00 00       	mov    $0xa,%edx
  4008ea:	31 f6                	xor    %esi,%esi
  4008ec:	e8 4f ff ff ff       	callq  400840 <strtol@plt>
int main(int argc, char *argv[])
{
    int alg = 0;
    if (argc == 2)
        alg = atoi(argv[1]);
    if (alg == 0) {
  4008f1:	85 c0                	test   %eax,%eax
  4008f3:	48 89 c3             	mov    %rax,%rbx
  4008f6:	74 c6                	je     4008be <main+0xe>
                "Usage: %s N\n"
                "       where N is algorithm number\n", argv[0]);
        return 1;
    }
//    printf("mat-mul-demo SIZE=%d\n",SIZE);
    mat_fill_random(m1);
  4008f8:	bf c0 1a 60 00       	mov    $0x601ac0,%edi
  4008fd:	e8 8e 09 00 00       	callq  401290 <mat_fill_random>
    print(m1);
    mat_fill_random(m2);
  400902:	bf c0 1a 80 00       	mov    $0x801ac0,%edi
  400907:	e8 84 09 00 00       	callq  401290 <mat_fill_random>
    print(m2);
    clock_t start = clock();
  40090c:	e8 4f ff ff ff       	callq  400860 <clock@plt>
    switch (alg) {
  400911:	8d 53 ff             	lea    -0x1(%rbx),%edx
//    printf("mat-mul-demo SIZE=%d\n",SIZE);
    mat_fill_random(m1);
    print(m1);
    mat_fill_random(m2);
    print(m2);
    clock_t start = clock();
  400914:	48 89 c5             	mov    %rax,%rbp
    switch (alg) {
  400917:	83 fa 04             	cmp    $0x4,%edx
  40091a:	0f 87 a5 00 00 00    	ja     4009c5 <main+0x115>
  400920:	ff 24 d5 48 14 40 00 	jmpq   *0x401448(,%rdx,8)
        break;
    case 3:
        mat_mul3(m1, m2, m3);
        break;
    case 4:
        mat_mul4(m1, m2, m3);
  400927:	ba c0 1a a0 00       	mov    $0xa01ac0,%edx
  40092c:	be c0 1a 80 00       	mov    $0x801ac0,%esi
  400931:	bf c0 1a 60 00       	mov    $0x601ac0,%edi
  400936:	e8 25 05 00 00       	callq  400e60 <mat_mul4>
        break;
    default:
        fprintf(stderr, "Error: invalid argument\n");
        break;
    };
    clock_t end = clock();
  40093b:	e8 20 ff ff ff       	callq  400860 <clock@plt>
    print(m3);
    printf("%.2f seconds\n", (double) (end - start) / CLOCKS_PER_SEC);
  400940:	66 0f ef c0          	pxor   %xmm0,%xmm0
  400944:	48 29 e8             	sub    %rbp,%rax
  400947:	bf 09 14 40 00       	mov    $0x401409,%edi
  40094c:	f2 48 0f 2a c0       	cvtsi2sd %rax,%xmm0
  400951:	b8 01 00 00 00       	mov    $0x1,%eax
  400956:	f2 0f 5e 05 2a 0b 00 	divsd  0xb2a(%rip),%xmm0        # 401488 <_IO_stdin_used+0xa8>
  40095d:	00 
  40095e:	e8 7d fe ff ff       	callq  4007e0 <printf@plt>
    return 0;
  400963:	31 c0                	xor    %eax,%eax
  400965:	e9 70 ff ff ff       	jmpq   4008da <main+0x2a>
        break;
    case 2:
        mat_mul2(m1, m2, m3);
        break;
    case 3:
        mat_mul3(m1, m2, m3);
  40096a:	ba c0 1a a0 00       	mov    $0xa01ac0,%edx
  40096f:	be c0 1a 80 00       	mov    $0x801ac0,%esi
  400974:	bf c0 1a 60 00       	mov    $0x601ac0,%edi
  400979:	e8 12 04 00 00       	callq  400d90 <mat_mul3>
        break;
  40097e:	eb bb                	jmp    40093b <main+0x8b>
    switch (alg) {
    case 1:
        mat_mul1(m1, m2, m3);
        break;
    case 2:
        mat_mul2(m1, m2, m3);
  400980:	ba c0 1a a0 00       	mov    $0xa01ac0,%edx
  400985:	be c0 1a 80 00       	mov    $0x801ac0,%esi
  40098a:	bf c0 1a 60 00       	mov    $0x601ac0,%edi
  40098f:	e8 ec 01 00 00       	callq  400b80 <mat_mul2>
        break;
  400994:	eb a5                	jmp    40093b <main+0x8b>
    mat_fill_random(m2);
    print(m2);
    clock_t start = clock();
    switch (alg) {
    case 1:
        mat_mul1(m1, m2, m3);
  400996:	ba c0 1a a0 00       	mov    $0xa01ac0,%edx
  40099b:	be c0 1a 80 00       	mov    $0x801ac0,%esi
  4009a0:	bf c0 1a 60 00       	mov    $0x601ac0,%edi
  4009a5:	e8 36 01 00 00       	callq  400ae0 <mat_mul1>
        break;
  4009aa:	eb 8f                	jmp    40093b <main+0x8b>
        break;
    case 4:
        mat_mul4(m1, m2, m3);
        break;
    case 5:
        mat_mul5(m1, m2, m3);
  4009ac:	ba c0 1a a0 00       	mov    $0xa01ac0,%edx
  4009b1:	be c0 1a 80 00       	mov    $0x801ac0,%esi
  4009b6:	bf c0 1a 60 00       	mov    $0x601ac0,%edi
  4009bb:	e8 40 05 00 00       	callq  400f00 <mat_mul5>
        break;
  4009c0:	e9 76 ff ff ff       	jmpq   40093b <main+0x8b>
    default:
        fprintf(stderr, "Error: invalid argument\n");
  4009c5:	48 8b 0d b4 10 20 00 	mov    0x2010b4(%rip),%rcx        # 601a80 <stderr@@GLIBC_2.2.5>
  4009cc:	ba 18 00 00 00       	mov    $0x18,%edx
  4009d1:	be 01 00 00 00       	mov    $0x1,%esi
  4009d6:	bf f0 13 40 00       	mov    $0x4013f0,%edi
  4009db:	e8 a0 fe ff ff       	callq  400880 <fwrite@plt>
        break;
  4009e0:	e9 56 ff ff ff       	jmpq   40093b <main+0x8b>

00000000004009e5 <_start>:
  4009e5:	31 ed                	xor    %ebp,%ebp
  4009e7:	49 89 d1             	mov    %rdx,%r9
  4009ea:	5e                   	pop    %rsi
  4009eb:	48 89 e2             	mov    %rsp,%rdx
  4009ee:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
  4009f2:	50                   	push   %rax
  4009f3:	54                   	push   %rsp
  4009f4:	49 c7 c0 d0 13 40 00 	mov    $0x4013d0,%r8
  4009fb:	48 c7 c1 60 13 40 00 	mov    $0x401360,%rcx
  400a02:	48 c7 c7 b0 08 40 00 	mov    $0x4008b0,%rdi
  400a09:	e8 22 fe ff ff       	callq  400830 <__libc_start_main@plt>
  400a0e:	f4                   	hlt    
  400a0f:	90                   	nop

0000000000400a10 <deregister_tm_clones>:
  400a10:	b8 77 1a 60 00       	mov    $0x601a77,%eax
  400a15:	55                   	push   %rbp
  400a16:	48 2d 70 1a 60 00    	sub    $0x601a70,%rax
  400a1c:	48 83 f8 0e          	cmp    $0xe,%rax
  400a20:	48 89 e5             	mov    %rsp,%rbp
  400a23:	76 1b                	jbe    400a40 <deregister_tm_clones+0x30>
  400a25:	b8 00 00 00 00       	mov    $0x0,%eax
  400a2a:	48 85 c0             	test   %rax,%rax
  400a2d:	74 11                	je     400a40 <deregister_tm_clones+0x30>
  400a2f:	5d                   	pop    %rbp
  400a30:	bf 70 1a 60 00       	mov    $0x601a70,%edi
  400a35:	ff e0                	jmpq   *%rax
  400a37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  400a3e:	00 00 
  400a40:	5d                   	pop    %rbp
  400a41:	c3                   	retq   
  400a42:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  400a49:	1f 84 00 00 00 00 00 

0000000000400a50 <register_tm_clones>:
  400a50:	be 70 1a 60 00       	mov    $0x601a70,%esi
  400a55:	55                   	push   %rbp
  400a56:	48 81 ee 70 1a 60 00 	sub    $0x601a70,%rsi
  400a5d:	48 c1 fe 03          	sar    $0x3,%rsi
  400a61:	48 89 e5             	mov    %rsp,%rbp
  400a64:	48 89 f0             	mov    %rsi,%rax
  400a67:	48 c1 e8 3f          	shr    $0x3f,%rax
  400a6b:	48 01 c6             	add    %rax,%rsi
  400a6e:	48 d1 fe             	sar    %rsi
  400a71:	74 15                	je     400a88 <register_tm_clones+0x38>
  400a73:	b8 00 00 00 00       	mov    $0x0,%eax
  400a78:	48 85 c0             	test   %rax,%rax
  400a7b:	74 0b                	je     400a88 <register_tm_clones+0x38>
  400a7d:	5d                   	pop    %rbp
  400a7e:	bf 70 1a 60 00       	mov    $0x601a70,%edi
  400a83:	ff e0                	jmpq   *%rax
  400a85:	0f 1f 00             	nopl   (%rax)
  400a88:	5d                   	pop    %rbp
  400a89:	c3                   	retq   
  400a8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000400a90 <__do_global_dtors_aux>:
  400a90:	80 3d f1 0f 20 00 00 	cmpb   $0x0,0x200ff1(%rip)        # 601a88 <completed.6661>
  400a97:	75 11                	jne    400aaa <__do_global_dtors_aux+0x1a>
  400a99:	55                   	push   %rbp
  400a9a:	48 89 e5             	mov    %rsp,%rbp
  400a9d:	e8 6e ff ff ff       	callq  400a10 <deregister_tm_clones>
  400aa2:	5d                   	pop    %rbp
  400aa3:	c6 05 de 0f 20 00 01 	movb   $0x1,0x200fde(%rip)        # 601a88 <completed.6661>
  400aaa:	f3 c3                	repz retq 
  400aac:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000400ab0 <frame_dummy>:
  400ab0:	bf d0 17 60 00       	mov    $0x6017d0,%edi
  400ab5:	48 83 3f 00          	cmpq   $0x0,(%rdi)
  400ab9:	75 05                	jne    400ac0 <frame_dummy+0x10>
  400abb:	eb 93                	jmp    400a50 <register_tm_clones>
  400abd:	0f 1f 00             	nopl   (%rax)
  400ac0:	b8 00 00 00 00       	mov    $0x0,%eax
  400ac5:	48 85 c0             	test   %rax,%rax
  400ac8:	74 f1                	je     400abb <frame_dummy+0xb>
  400aca:	55                   	push   %rbp
  400acb:	48 89 e5             	mov    %rsp,%rbp
  400ace:	ff d0                	callq  *%rax
  400ad0:	5d                   	pop    %rbp
  400ad1:	e9 7a ff ff ff       	jmpq   400a50 <register_tm_clones>
  400ad6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
  400add:	00 00 00 

0000000000400ae0 <mat_mul1>:

typedef double mat_t[SIZE][SIZE];

// textbook implementation O(N^3)
void mat_mul1(mat_t m1, mat_t m2, mat_t m3)
{
  400ae0:	41 54                	push   %r12
  400ae2:	49 89 d4             	mov    %rdx,%r12
  400ae5:	55                   	push   %rbp
  400ae6:	53                   	push   %rbx
  400ae7:	48 89 fd             	mov    %rdi,%rbp
  400aea:	48 89 f3             	mov    %rsi,%rbx
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
  400aed:	4c 89 e7             	mov    %r12,%rdi
  400af0:	31 f6                	xor    %esi,%esi
  400af2:	ba 00 00 20 00       	mov    $0x200000,%edx
  400af7:	e8 f4 fc ff ff       	callq  4007f0 <memset@plt>
  400afc:	49 8d b4 24 00 00 20 	lea    0x200000(%r12),%rsi
  400b03:	00 
  400b04:	48 89 ef             	mov    %rbp,%rdi
  400b07:	4d 89 e0             	mov    %r12,%r8

typedef double mat_t[SIZE][SIZE];

// textbook implementation O(N^3)
void mat_mul1(mat_t m1, mat_t m2, mat_t m3)
{
  400b0a:	31 c9                	xor    %ecx,%ecx
  400b0c:	0f 1f 40 00          	nopl   0x0(%rax)
  400b10:	f2 41 0f 10 0c 08    	movsd  (%r8,%rcx,1),%xmm1
  400b16:	48 8d 04 0b          	lea    (%rbx,%rcx,1),%rax
  400b1a:	4c 8d 8c 0b 00 00 20 	lea    0x200000(%rbx,%rcx,1),%r9
  400b21:	00 
  400b22:	48 89 fa             	mov    %rdi,%rdx
  400b25:	0f 1f 00             	nopl   (%rax)
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            for (k = 0; k < SIZE; ++k) {
                m3[i][j] += m1[i][k] * m2[k][j];
  400b28:	f2 0f 10 02          	movsd  (%rdx),%xmm0
  400b2c:	48 05 00 10 00 00    	add    $0x1000,%rax
  400b32:	48 83 c2 08          	add    $0x8,%rdx
  400b36:	f2 0f 59 80 00 f0 ff 	mulsd  -0x1000(%rax),%xmm0
  400b3d:	ff 
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            for (k = 0; k < SIZE; ++k) {
  400b3e:	49 39 c1             	cmp    %rax,%r9
                m3[i][j] += m1[i][k] * m2[k][j];
  400b41:	f2 0f 58 c8          	addsd  %xmm0,%xmm1
  400b45:	f2 41 0f 11 0c 08    	movsd  %xmm1,(%r8,%rcx,1)
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            for (k = 0; k < SIZE; ++k) {
  400b4b:	75 db                	jne    400b28 <mat_mul1+0x48>
  400b4d:	48 83 c1 08          	add    $0x8,%rcx
void mat_mul1(mat_t m1, mat_t m2, mat_t m3)
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
  400b51:	48 81 f9 00 10 00 00 	cmp    $0x1000,%rcx
  400b58:	75 b6                	jne    400b10 <mat_mul1+0x30>
  400b5a:	49 81 c0 00 10 00 00 	add    $0x1000,%r8
  400b61:	48 81 c7 00 10 00 00 	add    $0x1000,%rdi
// textbook implementation O(N^3)
void mat_mul1(mat_t m1, mat_t m2, mat_t m3)
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
  400b68:	49 39 f0             	cmp    %rsi,%r8
  400b6b:	75 9d                	jne    400b0a <mat_mul1+0x2a>
            for (k = 0; k < SIZE; ++k) {
                m3[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}
  400b6d:	5b                   	pop    %rbx
  400b6e:	5d                   	pop    %rbp
  400b6f:	41 5c                	pop    %r12
  400b71:	c3                   	retq   
  400b72:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  400b79:	1f 84 00 00 00 00 00 

0000000000400b80 <mat_mul2>:

*/

// slightly optimized textbook implementation O(N^3)
void mat_mul2(mat_t m1, mat_t m2, mat_t m3)
{
  400b80:	41 57                	push   %r15
  400b82:	41 56                	push   %r14
  400b84:	49 89 d6             	mov    %rdx,%r14
  400b87:	41 55                	push   %r13
  400b89:	41 54                	push   %r12
  400b8b:	49 89 fc             	mov    %rdi,%r12
  400b8e:	55                   	push   %rbp
  400b8f:	53                   	push   %rbx
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
  400b90:	4c 89 f7             	mov    %r14,%rdi
  400b93:	45 31 ff             	xor    %r15d,%r15d

*/

// slightly optimized textbook implementation O(N^3)
void mat_mul2(mat_t m1, mat_t m2, mat_t m3)
{
  400b96:	48 83 ec 48          	sub    $0x48,%rsp
  400b9a:	48 89 74 24 10       	mov    %rsi,0x10(%rsp)
  400b9f:	48 89 54 24 30       	mov    %rdx,0x30(%rsp)
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
  400ba4:	31 f6                	xor    %esi,%esi
  400ba6:	ba 00 00 20 00       	mov    $0x200000,%edx
  400bab:	e8 40 fc ff ff       	callq  4007f0 <memset@plt>
  400bb0:	48 c7 44 24 28 00 00 	movq   $0x0,0x28(%rsp)
  400bb7:	00 00 
  400bb9:	4c 89 f5             	mov    %r14,%rbp
  400bbc:	41 b9 fe 01 00 00    	mov    $0x1fe,%r9d
  400bc2:	bb 00 02 00 00       	mov    $0x200,%ebx
  400bc7:	48 c1 e5 3c          	shl    $0x3c,%rbp
  400bcb:	48 8b 74 24 10       	mov    0x10(%rsp),%rsi
  400bd0:	4f 8d 04 3c          	lea    (%r12,%r15,1),%r8
  400bd4:	48 c1 ed 3f          	shr    $0x3f,%rbp
  400bd8:	4d 8d 6f 08          	lea    0x8(%r15),%r13
    for (i = 0; i < SIZE; ++i) {
        for (k = 0; k < SIZE; ++k) {
            for (j = 0; j < SIZE; ++j) {
  400bdc:	31 c9                	xor    %ecx,%ecx
  400bde:	41 29 e9             	sub    %ebp,%r9d
  400be1:	29 eb                	sub    %ebp,%ebx
  400be3:	89 e8                	mov    %ebp,%eax
  400be5:	41 d1 e9             	shr    %r9d
  400be8:	89 5c 24 18          	mov    %ebx,0x18(%rsp)
  400bec:	41 83 c1 01          	add    $0x1,%r9d
  400bf0:	43 8d 1c 09          	lea    (%r9,%r9,1),%ebx
  400bf4:	89 5c 24 1c          	mov    %ebx,0x1c(%rsp)
  400bf8:	48 8b 5c 24 28       	mov    0x28(%rsp),%rbx
  400bfd:	48 8d 14 03          	lea    (%rbx,%rax,1),%rdx
  400c01:	48 8b 5c 24 30       	mov    0x30(%rsp),%rbx
  400c06:	48 c1 e0 03          	shl    $0x3,%rax
  400c0a:	4d 8d 14 07          	lea    (%r15,%rax,1),%r10
  400c0e:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  400c13:	49 8d 87 00 10 00 00 	lea    0x1000(%r15),%rax
  400c1a:	48 89 c7             	mov    %rax,%rdi
  400c1d:	48 89 44 24 38       	mov    %rax,0x38(%rsp)
  400c22:	48 89 d8             	mov    %rbx,%rax
  400c25:	48 01 f8             	add    %rdi,%rax
  400c28:	4c 8d 1c d3          	lea    (%rbx,%rdx,8),%r11
  400c2c:	49 01 da             	add    %rbx,%r10
  400c2f:	48 89 04 24          	mov    %rax,(%rsp)
  400c33:	4a 8d 44 3b 10       	lea    0x10(%rbx,%r15,1),%rax
  400c38:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  400c3d:	0f 1f 00             	nopl   (%rax)
  400c40:	49 8d 44 0d 00       	lea    0x0(%r13,%rcx,1),%rax
  400c45:	48 89 ca             	mov    %rcx,%rdx
  400c48:	48 c1 e2 09          	shl    $0x9,%rdx
  400c4c:	4c 01 e0             	add    %r12,%rax
  400c4f:	49 39 c6             	cmp    %rax,%r14
  400c52:	49 8d 04 0f          	lea    (%r15,%rcx,1),%rax
  400c56:	40 0f 93 c7          	setae  %dil
  400c5a:	4c 01 e0             	add    %r12,%rax
  400c5d:	48 39 04 24          	cmp    %rax,(%rsp)
  400c61:	0f 96 c0             	setbe  %al
  400c64:	40 08 c7             	or     %al,%dil
  400c67:	0f 84 f3 00 00 00    	je     400d60 <mat_mul2+0x1e0>
  400c6d:	48 8d 46 10          	lea    0x10(%rsi),%rax
  400c71:	49 39 c6             	cmp    %rax,%r14
  400c74:	40 0f 93 c7          	setae  %dil
  400c78:	48 3b 74 24 08       	cmp    0x8(%rsp),%rsi
  400c7d:	0f 93 c0             	setae  %al
  400c80:	40 08 c7             	or     %al,%dil
  400c83:	0f 84 d7 00 00 00    	je     400d60 <mat_mul2+0x1e0>
  400c89:	31 db                	xor    %ebx,%ebx
  400c8b:	85 ed                	test   %ebp,%ebp
  400c8d:	74 16                	je     400ca5 <mat_mul2+0x125>
                m3[i][j] += m1[i][k] * m2[k][j];
  400c8f:	f2 41 0f 10 04 08    	movsd  (%r8,%rcx,1),%xmm0
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (k = 0; k < SIZE; ++k) {
            for (j = 0; j < SIZE; ++j) {
  400c95:	b3 01                	mov    $0x1,%bl
                m3[i][j] += m1[i][k] * m2[k][j];
  400c97:	f2 0f 59 06          	mulsd  (%rsi),%xmm0
  400c9b:	f2 41 0f 58 06       	addsd  (%r14),%xmm0
  400ca0:	f2 41 0f 11 06       	movsd  %xmm0,(%r14)
  400ca5:	48 03 54 24 20       	add    0x20(%rsp),%rdx
  400caa:	f2 41 0f 10 0c 08    	movsd  (%r8,%rcx,1),%xmm1
  400cb0:	48 8b 44 24 10       	mov    0x10(%rsp),%rax
  400cb5:	66 0f 14 c9          	unpcklpd %xmm1,%xmm1
  400cb9:	48 8d 3c 10          	lea    (%rax,%rdx,1),%rdi
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (k = 0; k < SIZE; ++k) {
            for (j = 0; j < SIZE; ++j) {
  400cbd:	31 c0                	xor    %eax,%eax
  400cbf:	31 d2                	xor    %edx,%edx
  400cc1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                m3[i][j] += m1[i][k] * m2[k][j];
  400cc8:	66 0f 10 04 07       	movupd (%rdi,%rax,1),%xmm0
  400ccd:	83 c2 01             	add    $0x1,%edx
  400cd0:	66 0f 59 c1          	mulpd  %xmm1,%xmm0
  400cd4:	66 41 0f 58 04 03    	addpd  (%r11,%rax,1),%xmm0
  400cda:	41 0f 29 04 02       	movaps %xmm0,(%r10,%rax,1)
  400cdf:	48 83 c0 10          	add    $0x10,%rax
  400ce3:	44 39 ca             	cmp    %r9d,%edx
  400ce6:	72 e0                	jb     400cc8 <mat_mul2+0x148>
  400ce8:	8b 7c 24 1c          	mov    0x1c(%rsp),%edi
  400cec:	89 f8                	mov    %edi,%eax
  400cee:	01 d8                	add    %ebx,%eax
  400cf0:	39 7c 24 18          	cmp    %edi,0x18(%rsp)
  400cf4:	74 19                	je     400d0f <mat_mul2+0x18f>
  400cf6:	f2 41 0f 10 04 08    	movsd  (%r8,%rcx,1),%xmm0
  400cfc:	48 98                	cltq   
  400cfe:	49 8d 14 c6          	lea    (%r14,%rax,8),%rdx
  400d02:	f2 0f 59 04 c6       	mulsd  (%rsi,%rax,8),%xmm0
  400d07:	f2 0f 58 02          	addsd  (%rdx),%xmm0
  400d0b:	f2 0f 11 02          	movsd  %xmm0,(%rdx)
  400d0f:	48 83 c1 08          	add    $0x8,%rcx
  400d13:	48 81 c6 00 10 00 00 	add    $0x1000,%rsi
void mat_mul2(mat_t m1, mat_t m2, mat_t m3)
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (k = 0; k < SIZE; ++k) {
  400d1a:	48 81 f9 00 10 00 00 	cmp    $0x1000,%rcx
  400d21:	0f 85 19 ff ff ff    	jne    400c40 <mat_mul2+0xc0>
  400d27:	4c 8b 7c 24 38       	mov    0x38(%rsp),%r15
  400d2c:	49 81 c6 00 10 00 00 	add    $0x1000,%r14
  400d33:	48 81 44 24 28 00 02 	addq   $0x200,0x28(%rsp)
  400d3a:	00 00 
// slightly optimized textbook implementation O(N^3)
void mat_mul2(mat_t m1, mat_t m2, mat_t m3)
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
  400d3c:	49 81 ff 00 00 20 00 	cmp    $0x200000,%r15
  400d43:	0f 85 70 fe ff ff    	jne    400bb9 <mat_mul2+0x39>
            for (j = 0; j < SIZE; ++j) {
                m3[i][j] += m1[i][k] * m2[k][j];
            }
        }
    }
}
  400d49:	48 83 c4 48          	add    $0x48,%rsp
  400d4d:	5b                   	pop    %rbx
  400d4e:	5d                   	pop    %rbp
  400d4f:	41 5c                	pop    %r12
  400d51:	41 5d                	pop    %r13
  400d53:	41 5e                	pop    %r14
  400d55:	41 5f                	pop    %r15
  400d57:	c3                   	retq   
  400d58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  400d5f:	00 

*/

// slightly optimized textbook implementation O(N^3)
void mat_mul2(mat_t m1, mat_t m2, mat_t m3)
{
  400d60:	31 c0                	xor    %eax,%eax
  400d62:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (k = 0; k < SIZE; ++k) {
            for (j = 0; j < SIZE; ++j) {
                m3[i][j] += m1[i][k] * m2[k][j];
  400d68:	f2 41 0f 10 04 08    	movsd  (%r8,%rcx,1),%xmm0
  400d6e:	f2 0f 59 04 06       	mulsd  (%rsi,%rax,1),%xmm0
  400d73:	f2 41 0f 58 04 06    	addsd  (%r14,%rax,1),%xmm0
  400d79:	f2 41 0f 11 04 06    	movsd  %xmm0,(%r14,%rax,1)
  400d7f:	48 83 c0 08          	add    $0x8,%rax
{
    int i, j, k;
    memset(m3, 0, sizeof(mat_t));
    for (i = 0; i < SIZE; ++i) {
        for (k = 0; k < SIZE; ++k) {
            for (j = 0; j < SIZE; ++j) {
  400d83:	48 3d 00 10 00 00    	cmp    $0x1000,%rax
  400d89:	75 dd                	jne    400d68 <mat_mul2+0x1e8>
  400d8b:	eb 82                	jmp    400d0f <mat_mul2+0x18f>
  400d8d:	0f 1f 00             	nopl   (%rax)

0000000000400d90 <mat_mul3>:
        }
    }
}

void mat_mul3(mat_t m1, mat_t m2, mat_t m3)
{
  400d90:	66 0f ef d2          	pxor   %xmm2,%xmm2
  400d94:	4c 8d 92 00 00 20 00 	lea    0x200000(%rdx),%r10
  400d9b:	49 89 f9             	mov    %rdi,%r9
  400d9e:	45 31 c0             	xor    %r8d,%r8d
  400da1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
  400da8:	4a 8d 04 06          	lea    (%rsi,%r8,1),%rax
  400dac:	4a 8d bc 06 00 00 20 	lea    0x200000(%rsi,%r8,1),%rdi
  400db3:	00 
  400db4:	4c 89 c9             	mov    %r9,%rcx
  400db7:	66 0f 28 ca          	movapd %xmm2,%xmm1
  400dbb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            double sum = 0.0;
            int k;
            for (k = 0; k < SIZE; ++k) {
                sum += m1[i][k] * m2[k][j];
  400dc0:	f2 0f 10 01          	movsd  (%rcx),%xmm0
  400dc4:	48 05 00 10 00 00    	add    $0x1000,%rax
  400dca:	48 83 c1 08          	add    $0x8,%rcx
  400dce:	f2 0f 59 80 00 f0 ff 	mulsd  -0x1000(%rax),%xmm0
  400dd5:	ff 
    int i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            double sum = 0.0;
            int k;
            for (k = 0; k < SIZE; ++k) {
  400dd6:	48 39 c7             	cmp    %rax,%rdi
                sum += m1[i][k] * m2[k][j];
  400dd9:	f2 0f 58 c8          	addsd  %xmm0,%xmm1
    int i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            double sum = 0.0;
            int k;
            for (k = 0; k < SIZE; ++k) {
  400ddd:	75 e1                	jne    400dc0 <mat_mul3+0x30>
                sum += m1[i][k] * m2[k][j];
            }
            m3[i][j] = sum;
  400ddf:	f2 42 0f 11 0c 02    	movsd  %xmm1,(%rdx,%r8,1)
  400de5:	49 83 c0 08          	add    $0x8,%r8

void mat_mul3(mat_t m1, mat_t m2, mat_t m3)
{
    int i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
  400de9:	49 81 f8 00 10 00 00 	cmp    $0x1000,%r8
  400df0:	75 b6                	jne    400da8 <mat_mul3+0x18>
  400df2:	48 81 c2 00 10 00 00 	add    $0x1000,%rdx
  400df9:	49 81 c1 00 10 00 00 	add    $0x1000,%r9
}

void mat_mul3(mat_t m1, mat_t m2, mat_t m3)
{
    int i, j;
    for (i = 0; i < SIZE; ++i) {
  400e00:	4c 39 d2             	cmp    %r10,%rdx
  400e03:	75 99                	jne    400d9e <mat_mul3+0xe>
  400e05:	f3 c3                	repz retq 
  400e07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  400e0e:	00 00 

0000000000400e10 <mat_tran>:
        }
    }
}

void mat_tran(mat_t m1, mat_t m2)
{
  400e10:	4c 8d 87 00 10 00 00 	lea    0x1000(%rdi),%r8
  400e17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  400e1e:	00 00 
  400e20:	48 8d 8f 00 00 20 00 	lea    0x200000(%rdi),%rcx
  400e27:	48 89 f2             	mov    %rsi,%rdx
  400e2a:	48 89 f8             	mov    %rdi,%rax
  400e2d:	0f 1f 00             	nopl   (%rax)
    int i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            m2[i][j] = m1[j][i];
  400e30:	f2 0f 10 00          	movsd  (%rax),%xmm0
  400e34:	48 05 00 10 00 00    	add    $0x1000,%rax
  400e3a:	48 83 c2 08          	add    $0x8,%rdx
  400e3e:	f2 0f 11 42 f8       	movsd  %xmm0,-0x8(%rdx)

void mat_tran(mat_t m1, mat_t m2)
{
    int i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
  400e43:	48 39 c8             	cmp    %rcx,%rax
  400e46:	75 e8                	jne    400e30 <mat_tran+0x20>
  400e48:	48 83 c7 08          	add    $0x8,%rdi
  400e4c:	48 81 c6 00 10 00 00 	add    $0x1000,%rsi
}

void mat_tran(mat_t m1, mat_t m2)
{
    int i, j;
    for (i = 0; i < SIZE; ++i) {
  400e53:	4c 39 c7             	cmp    %r8,%rdi
  400e56:	75 c8                	jne    400e20 <mat_tran+0x10>
  400e58:	f3 c3                	repz retq 
  400e5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000400e60 <mat_mul4>:
        }
    }
}

void mat_mul4(mat_t m1, mat_t m2, mat_t m3)
{
  400e60:	55                   	push   %rbp
  400e61:	53                   	push   %rbx
  400e62:	48 89 f5             	mov    %rsi,%rbp
  400e65:	48 89 d3             	mov    %rdx,%rbx
                     const gsl_matrix * A,
                     const gsl_matrix * B,
                     double beta,
                     gsl_matrix * C);
*/
    gsl_matrix_view _m1 = gsl_matrix_view_array((double *) m1, SIZE, SIZE);
  400e68:	48 89 fe             	mov    %rdi,%rsi
  400e6b:	b9 00 02 00 00       	mov    $0x200,%ecx
        }
    }
}

void mat_mul4(mat_t m1, mat_t m2, mat_t m3)
{
  400e70:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
                     const gsl_matrix * A,
                     const gsl_matrix * B,
                     double beta,
                     gsl_matrix * C);
*/
    gsl_matrix_view _m1 = gsl_matrix_view_array((double *) m1, SIZE, SIZE);
  400e77:	ba 00 02 00 00       	mov    $0x200,%edx
  400e7c:	48 89 e7             	mov    %rsp,%rdi
  400e7f:	e8 cc f9 ff ff       	callq  400850 <gsl_matrix_view_array@plt>
    gsl_matrix_view _m2 = gsl_matrix_view_array((double *) m2, SIZE, SIZE);
  400e84:	48 8d 7c 24 30       	lea    0x30(%rsp),%rdi
  400e89:	48 89 ee             	mov    %rbp,%rsi
  400e8c:	b9 00 02 00 00       	mov    $0x200,%ecx
  400e91:	ba 00 02 00 00       	mov    $0x200,%edx
  400e96:	e8 b5 f9 ff ff       	callq  400850 <gsl_matrix_view_array@plt>
    gsl_matrix_view _m3 = gsl_matrix_view_array((double *) m3, SIZE, SIZE);
  400e9b:	48 8d 7c 24 60       	lea    0x60(%rsp),%rdi
  400ea0:	48 89 de             	mov    %rbx,%rsi
  400ea3:	b9 00 02 00 00       	mov    $0x200,%ecx
  400ea8:	ba 00 02 00 00       	mov    $0x200,%edx
  400ead:	e8 9e f9 ff ff       	callq  400850 <gsl_matrix_view_array@plt>
    gsl_blas_dgemm(CblasNoTrans, CblasNoTrans,
  400eb2:	66 0f ef c9          	pxor   %xmm1,%xmm1
  400eb6:	4c 8d 44 24 60       	lea    0x60(%rsp),%r8
  400ebb:	48 8d 4c 24 30       	lea    0x30(%rsp),%rcx
  400ec0:	f2 0f 10 05 a8 05 00 	movsd  0x5a8(%rip),%xmm0        # 401470 <_IO_stdin_used+0x90>
  400ec7:	00 
  400ec8:	48 89 e2             	mov    %rsp,%rdx
  400ecb:	be 6f 00 00 00       	mov    $0x6f,%esi
  400ed0:	bf 6f 00 00 00       	mov    $0x6f,%edi
  400ed5:	e8 96 f9 ff ff       	callq  400870 <gsl_blas_dgemm@plt>
                   1, &_m1.matrix,
                      &_m2.matrix,
                   0, &_m3.matrix);
}
  400eda:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
  400ee1:	5b                   	pop    %rbx
  400ee2:	5d                   	pop    %rbp
  400ee3:	c3                   	retq   
  400ee4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
  400eeb:	00 00 00 00 00 

0000000000400ef0 <min>:

inline size_t min(size_t a, size_t b) {
    return (a<b)? a : b;
  400ef0:	48 39 fe             	cmp    %rdi,%rsi
  400ef3:	48 89 f8             	mov    %rdi,%rax
  400ef6:	48 0f 46 c6          	cmovbe %rsi,%rax
}
  400efa:	c3                   	retq   
  400efb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000400f00 <mat_mul5>:

void mat_mul5(mat_t m1, mat_t m2, mat_t m3)
{
  400f00:	41 57                	push   %r15
  400f02:	41 56                	push   %r14
  400f04:	48 89 d0             	mov    %rdx,%rax
  400f07:	41 55                	push   %r13
  400f09:	41 54                	push   %r12
  400f0b:	55                   	push   %rbp
  400f0c:	53                   	push   %rbx
  400f0d:	48 83 ec 60          	sub    $0x60,%rsp
  400f11:	48 89 74 24 a8       	mov    %rsi,-0x58(%rsp)
  400f16:	48 89 7c 24 38       	mov    %rdi,0x38(%rsp)
  400f1b:	48 8d b0 00 00 20 00 	lea    0x200000(%rax),%rsi
  400f22:	48 89 54 24 f8       	mov    %rdx,-0x8(%rsp)
  400f27:	31 c0                	xor    %eax,%eax
  400f29:	48 8d 7a 08          	lea    0x8(%rdx),%rdi
  400f2d:	48 89 d1             	mov    %rdx,%rcx
  400f30:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
  400f37:	48 c7 82 f8 0f 00 00 	movq   $0x0,0xff8(%rdx)
  400f3e:	00 00 00 00 
  400f42:	48 81 c2 00 10 00 00 	add    $0x1000,%rdx
  400f49:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
  400f4d:	48 29 f9             	sub    %rdi,%rcx
  400f50:	81 c1 00 10 00 00    	add    $0x1000,%ecx
  400f56:	c1 e9 03             	shr    $0x3,%ecx
    const size_t step=64;
    size_t i,j,k,ii,jj,kk;
    for (i = 0; i < SIZE; i++) {
  400f59:	48 39 f2             	cmp    %rsi,%rdx
  400f5c:	f3 48 ab             	rep stos %rax,%es:(%rdi)
  400f5f:	75 c8                	jne    400f29 <mat_mul5+0x29>
  400f61:	48 c7 44 24 d0 00 00 	movq   $0x0,-0x30(%rsp)
  400f68:	00 00 
  400f6a:	48 8b 44 24 d0       	mov    -0x30(%rsp),%rax
  400f6f:	48 c7 44 24 e8 00 00 	movq   $0x0,-0x18(%rsp)
  400f76:	00 00 
  400f78:	48 83 c0 40          	add    $0x40,%rax
  400f7c:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  400f82:	48 89 c3             	mov    %rax,%rbx
  400f85:	48 89 04 24          	mov    %rax,(%rsp)
  400f89:	b8 00 02 00 00       	mov    $0x200,%eax
  400f8e:	48 0f 46 c3          	cmovbe %rbx,%rax
  400f92:	48 8b 5c 24 e8       	mov    -0x18(%rsp),%rbx
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
                    double x = m1[i][k];
                    for (j = jj; j < min(jj + step, SIZE); j++) {
  400f97:	45 31 ff             	xor    %r15d,%r15d
  400f9a:	48 89 c7             	mov    %rax,%rdi
  400f9d:	48 89 44 24 08       	mov    %rax,0x8(%rsp)
  400fa2:	45 31 f6             	xor    %r14d,%r14d
  400fa5:	48 89 d8             	mov    %rbx,%rax
  400fa8:	48 c1 e0 09          	shl    $0x9,%rax
  400fac:	48 89 44 24 28       	mov    %rax,0x28(%rsp)
  400fb1:	48 89 d8             	mov    %rbx,%rax
  400fb4:	48 c1 e0 06          	shl    $0x6,%rax
  400fb8:	48 89 44 24 10       	mov    %rax,0x10(%rsp)
  400fbd:	48 89 f8             	mov    %rdi,%rax
  400fc0:	48 8b 7c 24 38       	mov    0x38(%rsp),%rdi
  400fc5:	48 c1 e0 0c          	shl    $0xc,%rax
  400fc9:	48 89 44 24 20       	mov    %rax,0x20(%rsp)
  400fce:	48 89 d8             	mov    %rbx,%rax
  400fd1:	48 01 f8             	add    %rdi,%rax
  400fd4:	48 89 44 24 40       	mov    %rax,0x40(%rsp)
  400fd9:	49 8d 47 40          	lea    0x40(%r15),%rax
  400fdd:	41 bc 00 02 00 00    	mov    $0x200,%r12d
  400fe3:	48 8b 5c 24 a8       	mov    -0x58(%rsp),%rbx
  400fe8:	4c 8b 6c 24 f8       	mov    -0x8(%rsp),%r13
  400fed:	48 c7 44 24 b8 00 00 	movq   $0x0,-0x48(%rsp)
  400ff4:	00 00 
  400ff6:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  400ffc:	48 89 44 24 30       	mov    %rax,0x30(%rsp)
  401001:	4c 0f 46 e0          	cmovbe %rax,%r12
  401005:	48 8b 44 24 40       	mov    0x40(%rsp),%rax
  40100a:	4d 29 f5             	sub    %r14,%r13
  40100d:	48 89 44 24 d8       	mov    %rax,-0x28(%rsp)
  401012:	48 8b 44 24 28       	mov    0x28(%rsp),%rax
  401017:	4c 29 f0             	sub    %r14,%rax
  40101a:	48 01 d8             	add    %rbx,%rax
  40101d:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
  401022:	48 8b 44 24 20       	mov    0x20(%rsp),%rax
  401027:	4c 29 f0             	sub    %r14,%rax
  40102a:	48 01 d8             	add    %rbx,%rax
  40102d:	48 89 44 24 88       	mov    %rax,-0x78(%rsp)
  401032:	4c 89 e0             	mov    %r12,%rax
  401035:	4c 29 f8             	sub    %r15,%rax
  401038:	48 89 44 24 a0       	mov    %rax,-0x60(%rsp)
  40103d:	49 8d 47 01          	lea    0x1(%r15),%rax
  401041:	48 89 44 24 48       	mov    %rax,0x48(%rsp)
  401046:	4a 8d 04 fd 00 00 00 	lea    0x0(,%r15,8),%rax
  40104d:	00 
  40104e:	48 89 44 24 50       	mov    %rax,0x50(%rsp)
        }
    }
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
  401053:	48 8b 5c 24 d0       	mov    -0x30(%rsp),%rbx
  401058:	48 39 5c 24 08       	cmp    %rbx,0x8(%rsp)
  40105d:	0f 86 7c 01 00 00    	jbe    4011df <mat_mul5+0x2df>
  401063:	48 8b 44 24 a0       	mov    -0x60(%rsp),%rax
  401068:	4c 89 ed             	mov    %r13,%rbp
  40106b:	48 8b 5c 24 48       	mov    0x48(%rsp),%rbx
  401070:	48 c1 e5 3c          	shl    $0x3c,%rbp
  401074:	48 8b 74 24 f8       	mov    -0x8(%rsp),%rsi
                    double x = m1[i][k];
                    for (j = jj; j < min(jj + step, SIZE); j++) {
  401079:	4c 8b 54 24 18       	mov    0x18(%rsp),%r10
  40107e:	48 c1 ed 3f          	shr    $0x3f,%rbp
  401082:	4c 8b 5c 24 d8       	mov    -0x28(%rsp),%r11
  401087:	48 39 c5             	cmp    %rax,%rbp
  40108a:	48 0f 47 e8          	cmova  %rax,%rbp
  40108e:	48 85 ed             	test   %rbp,%rbp
  401091:	49 0f 44 df          	cmove  %r15,%rbx
  401095:	48 29 e8             	sub    %rbp,%rax
  401098:	4c 8d 40 fe          	lea    -0x2(%rax),%r8
  40109c:	48 89 44 24 90       	mov    %rax,-0x70(%rsp)
  4010a1:	48 89 5c 24 e0       	mov    %rbx,-0x20(%rsp)
  4010a6:	49 d1 e8             	shr    %r8
  4010a9:	49 83 c0 01          	add    $0x1,%r8
  4010ad:	4b 8d 04 00          	lea    (%r8,%r8,1),%rax
  4010b1:	48 89 c7             	mov    %rax,%rdi
  4010b4:	48 89 44 24 c0       	mov    %rax,-0x40(%rsp)
  4010b9:	48 8b 44 24 b8       	mov    -0x48(%rsp),%rax
  4010be:	4c 01 f8             	add    %r15,%rax
  4010c1:	48 01 e8             	add    %rbp,%rax
  4010c4:	48 8d 0c c6          	lea    (%rsi,%rax,8),%rcx
  4010c8:	4a 8d 44 3d 00       	lea    0x0(%rbp,%r15,1),%rax
  4010cd:	4b 8d 34 2e          	lea    (%r14,%r13,1),%rsi
  4010d1:	48 89 44 24 c8       	mov    %rax,-0x38(%rsp)
  4010d6:	48 89 f8             	mov    %rdi,%rax
  4010d9:	48 01 d8             	add    %rbx,%rax
  4010dc:	48 8b 5c 24 10       	mov    0x10(%rsp),%rbx
  4010e1:	48 89 44 24 f0       	mov    %rax,-0x10(%rsp)
  4010e6:	49 8d 45 10          	lea    0x10(%r13),%rax
  4010ea:	48 89 44 24 98       	mov    %rax,-0x68(%rsp)
  4010ef:	48 8b 44 24 50       	mov    0x50(%rsp),%rax
  4010f4:	48 01 f0             	add    %rsi,%rax
  4010f7:	48 89 44 24 b0       	mov    %rax,-0x50(%rsp)
  4010fc:	0f 1f 40 00          	nopl   0x0(%rax)
  401100:	4d 39 e7             	cmp    %r12,%r15
    }
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
                    double x = m1[i][k];
  401103:	f2 41 0f 10 0b       	movsd  (%r11),%xmm1
                    for (j = jj; j < min(jj + step, SIZE); j++) {
  401108:	0f 83 b4 00 00 00    	jae    4011c2 <mat_mul5+0x2c2>
  40110e:	49 8d 42 10          	lea    0x10(%r10),%rax
  401112:	4b 8d 3c 16          	lea    (%r14,%r10,1),%rdi
  401116:	49 39 c5             	cmp    %rax,%r13
  401119:	0f 93 c2             	setae  %dl
  40111c:	4c 3b 54 24 98       	cmp    -0x68(%rsp),%r10
  401121:	0f 93 c0             	setae  %al
  401124:	08 c2                	or     %al,%dl
  401126:	0f 84 2e 01 00 00    	je     40125a <mat_mul5+0x35a>
  40112c:	48 83 7c 24 a0 08    	cmpq   $0x8,-0x60(%rsp)
  401132:	0f 86 22 01 00 00    	jbe    40125a <mat_mul5+0x35a>
  401138:	48 85 ed             	test   %rbp,%rbp
  40113b:	74 17                	je     401154 <mat_mul5+0x254>
                        m3[i][j] += x * m2[k][j];
  40113d:	f2 42 0f 10 04 ff    	movsd  (%rdi,%r15,8),%xmm0
  401143:	48 8b 44 24 b0       	mov    -0x50(%rsp),%rax
  401148:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  40114c:	f2 0f 58 00          	addsd  (%rax),%xmm0
  401150:	f2 0f 11 00          	movsd  %xmm0,(%rax)
  401154:	48 83 7c 24 90 01    	cmpq   $0x1,-0x70(%rsp)
  40115a:	0f 84 f0 00 00 00    	je     401250 <mat_mul5+0x350>
  401160:	48 8b 44 24 c8       	mov    -0x38(%rsp),%rax
  401165:	66 0f 28 d1          	movapd %xmm1,%xmm2
  401169:	48 8b 54 24 a8       	mov    -0x58(%rsp),%rdx
  40116e:	66 0f 14 d2          	unpcklpd %xmm2,%xmm2
  401172:	48 01 d8             	add    %rbx,%rax
  401175:	4c 8d 0c c2          	lea    (%rdx,%rax,8),%r9
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
                    double x = m1[i][k];
                    for (j = jj; j < min(jj + step, SIZE); j++) {
  401179:	31 c0                	xor    %eax,%eax
  40117b:	31 d2                	xor    %edx,%edx
  40117d:	0f 1f 00             	nopl   (%rax)
                        m3[i][j] += x * m2[k][j];
  401180:	66 41 0f 10 04 01    	movupd (%r9,%rax,1),%xmm0
  401186:	48 83 c2 01          	add    $0x1,%rdx
  40118a:	66 0f 59 c2          	mulpd  %xmm2,%xmm0
  40118e:	66 0f 58 04 01       	addpd  (%rcx,%rax,1),%xmm0
  401193:	0f 29 04 01          	movaps %xmm0,(%rcx,%rax,1)
  401197:	48 83 c0 10          	add    $0x10,%rax
  40119b:	49 39 d0             	cmp    %rdx,%r8
  40119e:	77 e0                	ja     401180 <mat_mul5+0x280>
  4011a0:	48 8b 54 24 c0       	mov    -0x40(%rsp),%rdx
  4011a5:	48 39 54 24 90       	cmp    %rdx,-0x70(%rsp)
  4011aa:	74 16                	je     4011c2 <mat_mul5+0x2c2>
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
                    double x = m1[i][k];
                    for (j = jj; j < min(jj + step, SIZE); j++) {
  4011ac:	48 8b 54 24 f0       	mov    -0x10(%rsp),%rdx
                        m3[i][j] += x * m2[k][j];
  4011b1:	f2 0f 59 0c d7       	mulsd  (%rdi,%rdx,8),%xmm1
  4011b6:	48 8d 04 d6          	lea    (%rsi,%rdx,8),%rax
  4011ba:	f2 0f 58 08          	addsd  (%rax),%xmm1
  4011be:	f2 0f 11 08          	movsd  %xmm1,(%rax)
  4011c2:	49 83 c3 08          	add    $0x8,%r11
  4011c6:	49 81 c2 00 10 00 00 	add    $0x1000,%r10
  4011cd:	48 81 c3 00 02 00 00 	add    $0x200,%rbx
        }
    }
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
  4011d4:	4c 39 54 24 88       	cmp    %r10,-0x78(%rsp)
  4011d9:	0f 85 21 ff ff ff    	jne    401100 <mat_mul5+0x200>
  4011df:	48 81 44 24 b8 00 02 	addq   $0x200,-0x48(%rsp)
  4011e6:	00 00 
  4011e8:	48 81 44 24 d8 00 10 	addq   $0x1000,-0x28(%rsp)
  4011ef:	00 00 
  4011f1:	49 81 c5 00 10 00 00 	add    $0x1000,%r13
  4011f8:	48 8b 44 24 b8       	mov    -0x48(%rsp),%rax
            m3[i][j] = 0.0;
        }
    }
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
  4011fd:	48 3d 00 00 04 00    	cmp    $0x40000,%rax
  401203:	0f 85 4a fe ff ff    	jne    401053 <mat_mul5+0x153>
  401209:	4c 8b 7c 24 30       	mov    0x30(%rsp),%r15
  40120e:	49 81 ee 00 02 00 00 	sub    $0x200,%r14
        for (j = 0; j < SIZE; j++) {
            m3[i][j] = 0.0;
        }
    }
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
  401215:	49 81 ff 00 02 00 00 	cmp    $0x200,%r15
  40121c:	0f 85 b7 fd ff ff    	jne    400fd9 <mat_mul5+0xd9>
  401222:	48 8b 04 24          	mov    (%rsp),%rax
  401226:	48 81 44 24 e8 00 02 	addq   $0x200,-0x18(%rsp)
  40122d:	00 00 
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            m3[i][j] = 0.0;
        }
    }
    for (kk = 0; kk < SIZE; kk += step) {
  40122f:	48 3d 00 02 00 00    	cmp    $0x200,%rax
  401235:	48 89 44 24 d0       	mov    %rax,-0x30(%rsp)
  40123a:	0f 85 38 fd ff ff    	jne    400f78 <mat_mul5+0x78>
                    }
                }
            }
        }
    }
}
  401240:	48 83 c4 60          	add    $0x60,%rsp
  401244:	5b                   	pop    %rbx
  401245:	5d                   	pop    %rbp
  401246:	41 5c                	pop    %r12
  401248:	41 5d                	pop    %r13
  40124a:	41 5e                	pop    %r14
  40124c:	41 5f                	pop    %r15
  40124e:	c3                   	retq   
  40124f:	90                   	nop
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
                    double x = m1[i][k];
                    for (j = jj; j < min(jj + step, SIZE); j++) {
  401250:	48 8b 54 24 e0       	mov    -0x20(%rsp),%rdx
  401255:	e9 57 ff ff ff       	jmpq   4011b1 <mat_mul5+0x2b1>
  40125a:	4c 89 f8             	mov    %r15,%rax
  40125d:	0f 1f 00             	nopl   (%rax)
                        m3[i][j] += x * m2[k][j];
  401260:	f2 0f 10 04 c7       	movsd  (%rdi,%rax,8),%xmm0
  401265:	f2 0f 59 c1          	mulsd  %xmm1,%xmm0
  401269:	f2 0f 58 04 c6       	addsd  (%rsi,%rax,8),%xmm0
  40126e:	f2 0f 11 04 c6       	movsd  %xmm0,(%rsi,%rax,8)
    for (kk = 0; kk < SIZE; kk += step) {
        for (jj = 0; jj < SIZE; jj += step) {
            for (i = 0; i < SIZE; i++) {
                for (k = kk; k < min(kk + step, SIZE); k++) {
                    double x = m1[i][k];
                    for (j = jj; j < min(jj + step, SIZE); j++) {
  401273:	48 83 c0 01          	add    $0x1,%rax
  401277:	4c 39 e0             	cmp    %r12,%rax
  40127a:	75 e4                	jne    401260 <mat_mul5+0x360>
  40127c:	e9 41 ff ff ff       	jmpq   4011c2 <mat_mul5+0x2c2>
  401281:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
  401288:	0f 1f 84 00 00 00 00 
  40128f:	00 

0000000000401290 <mat_fill_random>:
        }
    }
}

void mat_fill_random(mat_t m)
{
  401290:	41 54                	push   %r12
  401292:	4c 8d a7 00 00 20 00 	lea    0x200000(%rdi),%r12
  401299:	55                   	push   %rbp
  40129a:	53                   	push   %rbx
  40129b:	48 89 fb             	mov    %rdi,%rbx
  40129e:	66 90                	xchg   %ax,%ax
  4012a0:	48 8d ab 00 10 00 00 	lea    0x1000(%rbx),%rbp
  4012a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  4012ae:	00 00 
    int i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            m[i][j] = 10.0 * rand() / (RAND_MAX + 1.0);
  4012b0:	e8 db f5 ff ff       	callq  400890 <rand@plt>
  4012b5:	66 0f ef c0          	pxor   %xmm0,%xmm0
  4012b9:	48 83 c3 08          	add    $0x8,%rbx
  4012bd:	f2 0f 2a c0          	cvtsi2sd %eax,%xmm0
  4012c1:	f2 0f 59 05 af 01 00 	mulsd  0x1af(%rip),%xmm0        # 401478 <_IO_stdin_used+0x98>
  4012c8:	00 
  4012c9:	f2 0f 59 05 af 01 00 	mulsd  0x1af(%rip),%xmm0        # 401480 <_IO_stdin_used+0xa0>
  4012d0:	00 
  4012d1:	f2 0f 11 43 f8       	movsd  %xmm0,-0x8(%rbx)

void mat_fill_random(mat_t m)
{
    int i, j;
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
  4012d6:	48 39 eb             	cmp    %rbp,%rbx
  4012d9:	75 d5                	jne    4012b0 <mat_fill_random+0x20>
}

void mat_fill_random(mat_t m)
{
    int i, j;
    for (i = 0; i < SIZE; ++i) {
  4012db:	49 39 dc             	cmp    %rbx,%r12
  4012de:	75 c0                	jne    4012a0 <mat_fill_random+0x10>
        for (j = 0; j < SIZE; ++j) {
            m[i][j] = 10.0 * rand() / (RAND_MAX + 1.0);
        }
    }
}
  4012e0:	5b                   	pop    %rbx
  4012e1:	5d                   	pop    %rbp
  4012e2:	41 5c                	pop    %r12
  4012e4:	c3                   	retq   
  4012e5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  4012ec:	00 00 00 00 

00000000004012f0 <mat_print>:

void mat_print(mat_t m)
{
  4012f0:	41 54                	push   %r12
  4012f2:	55                   	push   %rbp
  4012f3:	53                   	push   %rbx
  4012f4:	48 89 fb             	mov    %rdi,%rbx
    int i, j;
    printf("{\n");
  4012f7:	bf e4 13 40 00       	mov    $0x4013e4,%edi
  4012fc:	4c 8d a3 00 00 20 00 	lea    0x200000(%rbx),%r12
  401303:	e8 08 f5 ff ff       	callq  400810 <puts@plt>
  401308:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40130f:	00 
  401310:	48 8d ab 00 10 00 00 	lea    0x1000(%rbx),%rbp
  401317:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
  40131e:	00 00 
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
            printf("%10.6f ", m[i][j]);
  401320:	f2 0f 10 03          	movsd  (%rbx),%xmm0
  401324:	bf e6 13 40 00       	mov    $0x4013e6,%edi
  401329:	b8 01 00 00 00       	mov    $0x1,%eax
  40132e:	48 83 c3 08          	add    $0x8,%rbx
  401332:	e8 a9 f4 ff ff       	callq  4007e0 <printf@plt>
void mat_print(mat_t m)
{
    int i, j;
    printf("{\n");
    for (i = 0; i < SIZE; ++i) {
        for (j = 0; j < SIZE; ++j) {
  401337:	48 39 eb             	cmp    %rbp,%rbx
  40133a:	75 e4                	jne    401320 <mat_print+0x30>
            printf("%10.6f ", m[i][j]);
        }
        printf("\n");
  40133c:	bf 0a 00 00 00       	mov    $0xa,%edi
  401341:	e8 da f4 ff ff       	callq  400820 <putchar@plt>

void mat_print(mat_t m)
{
    int i, j;
    printf("{\n");
    for (i = 0; i < SIZE; ++i) {
  401346:	49 39 dc             	cmp    %rbx,%r12
  401349:	75 c5                	jne    401310 <mat_print+0x20>
            printf("%10.6f ", m[i][j]);
        }
        printf("\n");
    }
    printf("}\n");
}
  40134b:	5b                   	pop    %rbx
  40134c:	5d                   	pop    %rbp
  40134d:	41 5c                	pop    %r12
        for (j = 0; j < SIZE; ++j) {
            printf("%10.6f ", m[i][j]);
        }
        printf("\n");
    }
    printf("}\n");
  40134f:	bf ee 13 40 00       	mov    $0x4013ee,%edi
  401354:	e9 b7 f4 ff ff       	jmpq   400810 <puts@plt>
  401359:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000401360 <__libc_csu_init>:
  401360:	41 57                	push   %r15
  401362:	41 89 ff             	mov    %edi,%r15d
  401365:	41 56                	push   %r14
  401367:	49 89 f6             	mov    %rsi,%r14
  40136a:	41 55                	push   %r13
  40136c:	49 89 d5             	mov    %rdx,%r13
  40136f:	41 54                	push   %r12
  401371:	4c 8d 25 48 04 20 00 	lea    0x200448(%rip),%r12        # 6017c0 <__frame_dummy_init_array_entry>
  401378:	55                   	push   %rbp
  401379:	48 8d 2d 48 04 20 00 	lea    0x200448(%rip),%rbp        # 6017c8 <__init_array_end>
  401380:	53                   	push   %rbx
  401381:	4c 29 e5             	sub    %r12,%rbp
  401384:	31 db                	xor    %ebx,%ebx
  401386:	48 c1 fd 03          	sar    $0x3,%rbp
  40138a:	48 83 ec 08          	sub    $0x8,%rsp
  40138e:	e8 1d f4 ff ff       	callq  4007b0 <_init>
  401393:	48 85 ed             	test   %rbp,%rbp
  401396:	74 1e                	je     4013b6 <__libc_csu_init+0x56>
  401398:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
  40139f:	00 
  4013a0:	4c 89 ea             	mov    %r13,%rdx
  4013a3:	4c 89 f6             	mov    %r14,%rsi
  4013a6:	44 89 ff             	mov    %r15d,%edi
  4013a9:	41 ff 14 dc          	callq  *(%r12,%rbx,8)
  4013ad:	48 83 c3 01          	add    $0x1,%rbx
  4013b1:	48 39 eb             	cmp    %rbp,%rbx
  4013b4:	75 ea                	jne    4013a0 <__libc_csu_init+0x40>
  4013b6:	48 83 c4 08          	add    $0x8,%rsp
  4013ba:	5b                   	pop    %rbx
  4013bb:	5d                   	pop    %rbp
  4013bc:	41 5c                	pop    %r12
  4013be:	41 5d                	pop    %r13
  4013c0:	41 5e                	pop    %r14
  4013c2:	41 5f                	pop    %r15
  4013c4:	c3                   	retq   
  4013c5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
  4013cc:	00 00 00 00 

00000000004013d0 <__libc_csu_fini>:
  4013d0:	f3 c3                	repz retq 

Disassembly of section .fini:

00000000004013d4 <_fini>:
  4013d4:	48 83 ec 08          	sub    $0x8,%rsp
  4013d8:	48 83 c4 08          	add    $0x8,%rsp
  4013dc:	c3                   	retq   
